{
  "title": "Deep Residual Learning for Image Recognition",
  "authors": [
    "[Authors' names would be here]"
  ],
  "abstract": "Deeper neural networks are more difficult to train. We present a residual learning framework to ease the training of networks that are substantially deeper than those used previously. We explicitly reformulate the layers as learning residual functions with reference to the layer inputs, instead of learning unreferenced functions. We provide comprehensive empirical evidence showing that these residual networks are easier to optimize, and can gain accuracy from considerably increased depth. On the ImageNet dataset we evaluate residual nets with a depth of up to 152 layers\u20148\u00d7 deeper than VGG nets [41] but still having lower complexity. An ensemble of these residual nets achieves 3.57% error on the ImageNet test set. This result won the 1st place on the ILSVRC 2015 classification task. We also present analysis on CIFAR-10 with 100 and 1000 layers. The depth of representations is of central importance for many visual recognition tasks. Solely due to our extremely deep representations, we obtain a 28% relative improvement on the COCO object detection dataset. Deep residual nets are foundations of our submissions to ILSVRC & COCO 2015 competitions, where we also won the 1st places on the tasks of ImageNet detection, ImageNet localization, COCO detection, and COCO segmentation.",
  "keywords": [],
  "sections": [
    {
      "title": "Deep Residual Learning for Image Recognition",
      "content": "**Kaiming He**\n**Xiangyu Zhang**\n**Shaoqing Ren**\n**Jian Sun**\nMicrosoft Research\n{kahe, v-xiangz, v-shren, jiansun}@microsoft.com\n----",
      "level": 1
    },
    {
      "title": "Abstract",
      "content": "Deeper neural networks are more difficult to train. We present a residual learning framework to ease the training of networks that are substantially deeper than those used previously. We explicitly reformulate the layers as learning residual functions with reference to the layer inputs, instead of learning unreferenced functions. We provide comprehensive empirical evidence showing that these residual networks are easier to optimize, and can gain accuracy from considerably increased depth. On the ImageNet dataset we evaluate residual nets with a depth of up to 152 layers\u20148\u00d7 deeper than VGG nets [41] but still having lower complexity. An ensemble of these residual nets achieves 3.57% error on the ImageNet test set. This result won the 1st place on the ILSVRC 2015 classification task. We also present analysis on CIFAR-10 with 100 and 1000 layers.\nThe depth of representations is of central importance for many visual recognition tasks. Solely due to our extremely deep representations, we obtain a 28% relative improvement on the COCO object detection dataset. Deep residual nets are foundations of our submissions to ILSVRC & COCO 2015 competitions, where we also won the 1st places on the tasks of ImageNet detection, ImageNet localization, COCO detection, and COCO segmentation.",
      "level": 2
    },
    {
      "title": "1. Introduction",
      "content": "Deep convolutional neural networks [22, 21] have led to a series of breakthroughs for image classification [21, 50, 40]. Deep networks naturally integrate low/mid/high-level features [50] and classifiers in an end-to-end multi-layer fashion, and the \u201clevels\u201d of features can be enriched by the number of stacked layers (depth). Recent evidence [41, 44] reveals that network depth is of crucial importance, and the leading results [41, 44, 13, 16] on the challenging ImageNet dataset [36] all exploit \u201cvery deep\u201d [41] models, with a depth of sixteen [41] to thirty [16]. Many other non-trivial visual recognition tasks [8, 12, 7, 32, 27] have also greatly benefited from very deep models.\nDriven by the significance of depth, a question arises: Is learning better networks as easy as stacking more layers? An obstacle to answering this question was the notorious problem of vanishing/exploding gradients [1, 9], which hamper convergence from the beginning. This problem, however, has been largely addressed by normalized initialization [23, 9, 37, 13] and intermediate normalization layers [16], which enable networks with tens of layers to start converging for stochastic gradient descent (SGD) with backpropagation [22].\nWhen deeper networks are able to start converging, a degradation problem has been exposed: with the network depth increasing, accuracy gets saturated (which might be unsurprising) and then degrades rapidly. Unexpectedly, such degradation is not caused by overfitting, and adding more layers to a suitably deep model leads to higher training error, as reported in [11, 42] and thoroughly verified by our experiments. Fig. 1 shows a typical example.\nThe degradation (of training accuracy) indicates that not all systems are similarly easy to optimize. Let us consider a shallower architecture and its deeper counterpart that adds more layers onto it. There exists a solution by construction to the deeper model: the added layers are identity mapping, and the other layers are copied from the learned shallower model. The existence of this constructed solution indicates that a deeper model should produce no higher training error than its shallower counterpart. But experiments show that our current solvers on hand are unable to find solutions that...\n----\n**Figure 1.** Training error (left) and test error (right) on CIFAR-10 with 20-layer and 56-layer \u201cplain\u201d networks. The deeper network has higher training error, and thus test error. Similar phenomena on ImageNet is presented in Fig. 4.\n---",
      "level": 2
    },
    {
      "title": "Deep Residual Learning for Image Recognition",
      "content": "",
      "level": 1
    },
    {
      "title": "Abstract",
      "content": "In this paper, we address the degradation problem by introducing a deep residual learning framework. Instead of hoping each few stacked layers directly fit a desired underlying mapping, we explicitly let these layers fit a residual mapping. Formally, denoting the desired underlying mapping as $H(x)$, we let the stacked nonlinear layers fit another mapping of $F(x) := H(x)\u2212x$. The original mapping is recast into $F(x)+x$. We hypothesize that it is easier to optimize the residual mapping than to optimize the original, unreferenced mapping. To the extreme, if an identity mapping were optimal, it would be easier to push the residual to zero than to fit an identity mapping by a stack of nonlinear layers.\nThe formulation of $F(x) + x$ can be realized by feedforward neural networks with \u201cshortcut connections\u201d (Fig. 2). Shortcut connections [2, 34, 49] are those skipping one or more layers. In our case, the shortcut connections simply perform identity mapping, and their outputs are added to the outputs of the stacked layers (Fig. 2). Identity shortcut connections add neither extra parameter nor computational complexity. The entire network can still be trained end-to-end by SGD with backpropagation, and can be easily implemented using common libraries (e.g., Caffe [19]) without modifying the solvers.\nWe present comprehensive experiments on ImageNet [36] to show the degradation problem and evaluate our method. We show that: 1) Our extremely deep residual nets are easy to optimize, but the counterpart \u201cplain\u201d nets (that simply stack layers) exhibit higher training error when the depth increases; 2) Our deep residual nets can easily enjoy accuracy gains from greatly increased depth, producing results substantially better than previous networks.\nSimilar phenomena are also shown on the CIFAR-10 set [20], suggesting that the optimization difficulties and the effects of our method are not just akin to a particular dataset. We present successfully trained models on this dataset with over 100 layers, and explore models with over 1000 layers.\nOn the ImageNet classification dataset [36], we obtain excellent results by extremely deep residual nets. Our 152-layer residual net is the deepest network ever presented on ImageNet, while still having lower complexity than VGG nets [41]. Our ensemble has 3.57% top-5 error on the ImageNet test set, and won the 1st place in the ILSVRC 2015 classification competition. The extremely deep representations also have excellent generalization performance on other recognition tasks, and lead us to further win the 1st places on: ImageNet detection, ImageNet localization, COCO detection, and COCO segmentation in ILSVRC & COCO 2015 competitions. This strong evidence shows that the residual learning principle is generic, and we expect that it is applicable in other vision and non-vision problems.",
      "level": 2
    },
    {
      "title": "1. Introduction",
      "content": "The degradation problem refers to the observation that as the depth of a neural network increases, the training accuracy gets saturated and then degrades rapidly. This is counterintuitive, as one would expect that a deeper model should perform at least as well as a shallower one. The degradation problem arises not because of overfitting, but due to the difficulty of optimizing the parameters of very deep networks.\nIn this paper, we address the degradation problem by introducing a deep residual learning framework. Instead of hoping each few stacked layers directly fit a desired underlying mapping, we explicitly let these layers fit a residual mapping. Formally, denoting the desired underlying mapping as $H(x)$, we let the stacked nonlinear layers fit another mapping of $F(x) := H(x)\u2212x$. The original mapping is recast into $F(x)+x$. We hypothesize that it is easier to optimize the residual mapping than to optimize the original, unreferenced mapping. To the extreme, if an identity mapping were optimal, it would be easier to push the residual to zero than to fit an identity mapping by a stack of nonlinear layers.\nThe formulation of $F(x) + x$ can be realized by feedforward neural networks with \u201cshortcut connections\u201d (Fig. 2). Shortcut connections [2, 34, 49] are those skipping one or more layers. In our case, the shortcut connections simply perform identity mapping, and their outputs are added to the outputs of the stacked layers (Fig. 2). Identity shortcut connections add neither extra parameter nor computational complexity. The entire network can still be trained end-to-end by SGD with backpropagation, and can be easily implemented using common libraries (e.g., Caffe [19]) without modifying the solvers.\nWe present comprehensive experiments on ImageNet [36] to show the degradation problem and evaluate our method. We show that: 1) Our extremely deep residual nets are easy to optimize, but the counterpart \u201cplain\u201d nets (that simply stack layers) exhibit higher training error when the depth increases; 2) Our deep residual nets can easily enjoy accuracy gains from greatly increased depth, producing results substantially better than previous networks.\nSimilar phenomena are also shown on the CIFAR-10 set [20], suggesting that the optimization difficulties and the effects of our method are not just akin to a particular dataset. We present successfully trained models on this dataset with over 100 layers, and explore models with over 1000 layers.\nOn the ImageNet classification dataset [36], we obtain excellent results by extremely deep residual nets. Our 152-layer residual net is the deepest network ever presented on ImageNet, while still having lower complexity than VGG nets [41]. Our ensemble has 3.57% top-5 error on the ImageNet test set, and won the 1st place in the ILSVRC 2015 classification competition. The extremely deep representations also have excellent generalization performance on other recognition tasks, and lead us to further win the 1st places on: ImageNet detection, ImageNet localization, COCO detection, and COCO segmentation in ILSVRC & COCO 2015 competitions. This strong evidence shows that the residual learning principle is generic, and we expect that it is applicable in other vision and non-vision problems.",
      "level": 2
    },
    {
      "title": "2. Related Work",
      "content": "",
      "level": 2
    },
    {
      "title": "Residual Representations",
      "content": "In image recognition, VLAD [18] is a representation that encodes by the residual vectors with respect to a dictionary, and Fisher Vector [30] can be formulated as a probabilistic version [18] of VLAD. Both of them are powerful shallow representations for image retrieval and classification [4, 48]. For vector quantization, encoding residual vectors [17] is shown to be more effective than encoding original vectors.\nIn low-level vision and computer graphics, for solving Partial Differential Equations (PDEs), the widely used Multigrid method [3] reformulates the system as subproblems at multiple scales, where each subproblem is responsible for the residual solution between a coarser and a finer scale. An alternative to Multigrid is hierarchical basis preconditioning [45, 46], which relies on variables that represent residual vectors between two scales. It has been shown [3, 45, 46] that these solvers converge much faster than standard solvers that are unaware of the residual nature of the solutions. These methods suggest that a good reformulation or preconditioning can simplify the optimization.",
      "level": 3
    },
    {
      "title": "Shortcut Connections",
      "content": "Practices and theories that lead to shortcut connections [2, 34, 49] have been studied for a long time. An early practice of training multi-layer perceptrons (MLPs) is to add a linear layer connected from the network input to the output [34, 49]. In [44, 24], a few intermediate layers are directly connected to auxiliary classifiers for addressing vanishing/exploding gradients. The papers of [39, 38, 31, 47] propose methods for centering layer responses, gradients, and propagated errors, implemented by shortcut connections. In [44], an \u201cinception\u201d layer is composed of a shortcut branch and a few deeper branches.\nConcurrent with our work, \u201chighway networks\u201d [42, 43] present shortcut connections with gating functions [15]. These gates are data-dependent and have parameters, in contrast to our identity shortcuts that are parameter-free. When a gated shortcut is \u201cclosed\u201d (approaching zero), the layers in highway networks represent non-residual functions. On the contrary, our formulation always learns residual functions; our identity shortcuts are never closed, and all information is always passed through, with additional residual functions to be learned.",
      "level": 3
    },
    {
      "title": "Figure 2",
      "content": "Residual learning: a building block.\n---",
      "level": 2
    },
    {
      "title": "Deep Residual Learning",
      "content": "",
      "level": 1
    },
    {
      "title": "3. Deep Residual Learning",
      "content": "",
      "level": 2
    },
    {
      "title": "3.1. Residual Learning",
      "content": "Let us consider $H(x)$ as an underlying mapping to be fit by a few stacked layers (not necessarily the entire net), with $x$ denoting the inputs to the first of these layers. If one hypothesizes that multiple nonlinear layers can asymptotically approximate complicated functions, then it is equivalent to hypothesize that they can asymptotically approximate the residual functions, i.e., $H(x) - x$ (assuming that the input and output are of the same dimensions). So rather than expect stacked layers to approximate $H(x)$, we explicitly let these layers approximate a residual function $F(x) := H(x) - x$. The original function thus becomes $F(x) + x$. Although both forms should be able to asymptotically approximate the desired functions (as hypothesized), the ease of learning might be different.\nThis reformulation is motivated by the counterintuitive phenomena about the degradation problem (Fig. 1, left). As we discussed in the introduction, if the added layers can be constructed as identity mappings, a deeper model should have training error no greater than its shallower counterpart. The degradation problem suggests that the solvers might have difficulties in approximating identity mappings by multiple nonlinear layers. With the residual learning reformulation, if identity mappings are optimal, the solvers may simply drive the weights of the multiple nonlinear layers toward zero to approach identity mappings.\nIn real cases, it is unlikely that identity mappings are optimal, but our reformulation may help to precondition the problem. If the optimal function is closer to an identity mapping than to a zero mapping, it should be easier for the solver to find the perturbations with reference to an identity mapping than to learn the function as a new one. We show by experiments (Fig. 7) that the learned residual functions in general have small responses, suggesting that identity mappings provide reasonable preconditioning.",
      "level": 3
    },
    {
      "title": "3.2. Identity Mapping by Shortcuts",
      "content": "We adopt residual learning to every few stacked layers. A building block is shown in Fig. 2. Formally, in this paper we consider a building block defined as:\n$$\ny = F(x, \\{W_i\\}) + x. \\tag{1}\n$$\nHere $x$ and $y$ are the input and output vectors of the layers considered. The function $F(x, \\{W_i\\})$ represents the residual mapping to be learned. For the example in Fig. 2 that has two layers, $F = W_2 \\sigma(W_1 x)$ in which $\\sigma$ denotes ReLU and the biases are omitted for simplifying notations. The operation $F + x$ is performed by a shortcut connection and element-wise addition. We adopt the second nonlinearity after the addition (i.e., $\\sigma(y)$, see Fig. 2).\nThe shortcut connections in Eqn. (1) introduce neither extra parameter nor computation complexity. This is not only attractive in practice but also important in our comparisons between plain and residual networks. We can fairly compare plain/residual networks that simultaneously have the same number of parameters, depth, width, and computational cost (except for the negligible element-wise addition). The dimensions of $x$ and $F$ must be equal in Eqn. (1). If this is not the case (e.g., when changing the input/output channels), we can perform a linear projection $W_s$ by the shortcut connections to match the dimensions:\n$$\ny = F(x, \\{W_i\\}) + W_s x. \\tag{2}\n$$\nWe can also use a square matrix $W_s$ in Eqn. (1). But we will show by experiments that the identity mapping is sufficient for addressing the degradation problem and is economical, and thus $W_s$ is only used when matching dimensions.\nThe form of the residual function $F$ is flexible. Experiments in this paper involve a function $F$ that has two or three layers (Fig. 5), while more layers are possible. But if $F$ has only a single layer, Eqn. (1) is similar to a linear layer: $y = W_1 x + x$, for which we have not observed advantages.\nWe also note that although the above notations are about fully-connected layers for simplicity, they are applicable to convolutional layers. The function $F(x, \\{W_i\\})$ can represent multiple convolutional layers. The element-wise addition is performed on two feature maps, channel by channel.",
      "level": 3
    },
    {
      "title": "3.3. Network Architectures",
      "content": "We have tested various plain/residual nets, and have observed consistent phenomena. To provide instances for discussion, we describe two models for ImageNet as follows.\n**Plain Network.** Our plain baselines (Fig. 3, middle) are mainly inspired by the philosophy of VGG nets (Fig. 3, left). The convolutional layers mostly have $3 \\times 3$ filters and follow two simple design rules: (i) for the same output feature map size, the layers have the same number of filters; and (ii) if the feature map size is halved, the number of filters is doubled so as to preserve the time complexity per layer. We perform downsampling directly by convolutional layers that have a stride of 2. The network ends with a global average pooling layer and a 1000-way fully-connected layer with softmax. The total number of weighted layers is 34 in Fig. 3 (middle).\nIt is worth noticing that our model has fewer filters and lower complexity than VGG nets (Fig. 3, left). Our 34-layer baseline has 3.6 billion FLOPs (multiply-adds), which is only 18% of VGG-19 (19.6 billion FLOPs).\n---",
      "level": 3
    },
    {
      "title": "Title: Residual Networks",
      "content": "",
      "level": 1
    },
    {
      "title": "Authors: [Authors' names would be here]",
      "content": "",
      "level": 2
    },
    {
      "title": "Abstract",
      "content": "[Abstract text would be here]",
      "level": 2
    },
    {
      "title": "1. Introduction",
      "content": "[Introduction text would be here]",
      "level": 2
    },
    {
      "title": "2. Related Work",
      "content": "[Related work text would be here]",
      "level": 2
    },
    {
      "title": "3. Methodology",
      "content": "",
      "level": 2
    },
    {
      "title": "3.1. Network Architecture",
      "content": "The architecture of the networks used in this study is illustrated in Figure 3. The left side shows the VGG-19 model [41] (19.6 billion FLOPs) as a reference. The middle section depicts a plain network with 34 parameter layers (3.6 billion FLOPs). The right side illustrates a residual network with 34 parameter layers (3.6 billion FLOPs). The dotted shortcuts increase dimensions.",
      "level": 3
    },
    {
      "title": "3.1.1. VGG-19",
      "content": "- **Input Image Size**: 224\n- **Output Size**: 3x3 conv, 64\n- **Pooling**: pool, /2\n- **Output Size**: 112\n- **Convolutions**:\n- 3x3 conv, 128\n- 3x3 conv, 256\n- 3x3 conv, 512\n- **Output Size**: 56\n- **Pooling**: pool, /2\n- **Output Size**: 28\n- **Convolutions**:\n- 3x3 conv, 512\n- **Output Size**: 14\n- **Convolutions**:\n- 3x3 conv, 512\n- **Output Size**: 7\n- **Fully Connected Layers**:\n- fc 4096\n- fc 1000",
      "level": 4
    },
    {
      "title": "3.2. Implementation",
      "content": "Our implementation for ImageNet follows the practice in [21, 41]. The image is resized with its shorter side randomly sampled in [256, 480] for scale augmentation [41]. A 224\u00d7224 crop is randomly sampled from an image or its horizontal flip, with the per-pixel mean subtracted [21]. The standard color augmentation in [21] is used. We adopt batch normalization (BN) [16] right after each convolution and before activation, following [16]. We initialize the weights as in [13] and train all plain/residual nets from scratch. We use SGD with a mini-batch size of 256. The learning rate starts from 0.1 and is divided by 10 when the error plateaus, and the models are trained for up to 60 \u00d7 10^4 iterations. We use a weight decay of 0.0001 and a momentum of 0.9. We do not use dropout [14], following the practice in [16].\nIn testing, for comparison studies we adopt the standard 10-crop testing [21]. For best results, we adopt the fully-convolutional form as in [41, 13], and average the scores at multiple scales (images are resized such that the shorter side is in {224, 256, 384, 480, 640}).",
      "level": 3
    },
    {
      "title": "4. Experiments",
      "content": "",
      "level": 2
    },
    {
      "title": "4.1. ImageNet Classification",
      "content": "We evaluate our method on the ImageNet 2012 classification dataset [36] that consists of 1000 classes. The models are trained on the 1.28 million training images and evaluated on the 50k validation images. We also obtain a final result on the 100k test images, reported by the test server. We evaluate both top-1 and top-5 error rates.",
      "level": 3
    },
    {
      "title": "Plain Networks",
      "content": "We first evaluate 18-layer and 34-layer plain nets. The 34-layer plain net is in Fig. 3 (middle). The 18-layer plain net is of a similar form. See Table 1 for detailed architectures. The results in Table 2 show that the deeper 34-layer plain net has higher validation error than the shallower 18-layer plain net. To reveal the reasons, in Fig. 4 (left) we compare their training/validation errors during the training procedure. We have observed the degradation problem.",
      "level": 4
    },
    {
      "title": "Figures",
      "content": "- **Figure 3**: Example network architectures for ImageNet. Left: the VGG-19 model [41] (19.6 billion FLOPs) as a reference. Middle: a plain network with 34 parameter layers (3.6 billion FLOPs). Right: a residual network with 34 parameter layers (3.6 billion FLOPs). The dotted shortcuts increase dimensions. Table 1 shows more details and other variants.",
      "level": 2
    },
    {
      "title": "Tables",
      "content": "- **Table 1**: Detailed architectures of the networks.\n- **Table 2**: Validation errors of the plain networks.",
      "level": 2
    },
    {
      "title": "References",
      "content": "[1] [Reference details would be here]\n[2] [Reference details would be here]\n[3] [Reference details would be here]\n[4] [Reference details would be here]\n[5] [Reference details would be here]\n[6] [Reference details would be here]\n[7] [Reference details would be here]\n[8] [Reference details would be here]\n[9] [Reference details would be here]\n[10] [Reference details would be here]",
      "level": 2
    },
    {
      "title": "Footnotes",
      "content": "[Footnote text would be here]\n---",
      "level": 2
    },
    {
      "title": "Title: Residual Networks (ResNets)",
      "content": "",
      "level": 1
    },
    {
      "title": "Authors: [Authors' names would be here]",
      "content": "",
      "level": 2
    },
    {
      "title": "Abstract",
      "content": "[Abstract text would be here]",
      "level": 2
    },
    {
      "title": "1. Introduction",
      "content": "[Introduction text would be here]",
      "level": 2
    },
    {
      "title": "2. Methodology",
      "content": "",
      "level": 2
    },
    {
      "title": "2.1 Network Architecture",
      "content": "Table 1. Architectures for ImageNet. Building blocks are shown in brackets (see also Fig. 5), with the numbers of blocks stacked. Down-sampling is performed by conv3 1, conv4 1, and conv5 1 with a stride of 2.\n\\[\n\\begin{array}{|c|c|c|c|c|c|}\n\\hline\n\\text{layer name} & \\text{output size} & \\text{18-layer} & \\text{34-layer} & \\text{50-layer} & \\text{101-layer} & \\text{152-layer} \\\\\n\\hline\n\\text{conv1} & 112 \\times 112 & & & & & \\\\\n& & 7 \\times 7, 64, \\text{ stride } 2 & & & & \\\\\n& & 3 \\times 3 \\text{ max pool, stride } 2 & & & & \\\\\n\\hline\n\\text{conv2} & 56 \\times 56 & [3 \\times 3, 64] & [3 \\times 3, 64] & 1 \\times 1, 64 & 1 \\times 1, 64 & 1 \\times 1, 64 \\\\\n& & 3 \\times 3, 64 \\times 2 & 3 \\times 3, 64 \\times 3 & 3 \\times 3, 64 \\times 3 & 3 \\times 3, 64 \\times 3 & 3 \\times 3, 64 \\times 3 \\\\\n& & [ ] & [ ] & 1 \\times 1, 256 & 1 \\times 1, 256 & 1 \\times 1, 256 \\\\\n\\hline\n\\text{conv3} & 28 \\times 28 & 3 \\times 3, 128 \\times 2 & 3 \\times 3, 128 \\times 4 & 1 \\times 1, 128 & 1 \\times 1, 128 & 1 \\times 1, 128 \\\\\n& & 3 \\times 3, 128 & 3 \\times 3, 128 & 3 \\times 3, 128 \\times 4 & 3 \\times 3, 128 \\times 4 & 3 \\times 3, 128 \\times 8 \\\\\n& & [ ] & [ ] & 1 \\times 1, 512 & 1 \\times 1, 512 & 1 \\times 1, 512 \\\\\n\\hline\n\\text{conv4} & 14 \\times 14 & 3 \\times 3, 256 \\times 2 & 3 \\times 3, 256 \\times 6 & 1 \\times 1, 256 & 1 \\times 1, 256 & 1 \\times 1, 256 \\\\\n& & 3 \\times 3, 256 & 3 \\times 3, 256 & 3 \\times 3, 256 \\times 6 & 3 \\times 3, 256 \\times 23 & 3 \\times 3, 256 \\times 36 \\\\\n& & [ ] & [ ] & 1 \\times 1, 1024 & 1 \\times 1, 1024 & 1 \\times 1, 1024 \\\\\n\\hline\n\\text{conv5} & 7 \\times 7 & 3 \\times 3, 512 \\times 2 & 3 \\times 3, 512 \\times 3 & 1 \\times 1, 512 & 1 \\times 1, 512 & 1 \\times 1, 512 \\\\\n& & 3 \\times 3, 512 & 3 \\times 3, 512 & 3 \\times 3, 512 \\times 3 & 3 \\times 3, 512 \\times 3 & 3 \\times 3, 512 \\times 3 \\\\\n& & & & 1 \\times 2048 & 1 \\times 2048 & 1 \\times 2048 \\\\\n\\hline\n& & 1 \\times 1 & & \\text{average pool, 1000-d fc, softmax} & & \\\\\n\\hline\n\\text{FLOPs} & & 1.8 \\times 10^9 & 3.6 \\times 10^9 & 3.8 \\times 10^9 & 7.6 \\times 10^9 & 11.3 \\times 10^9 \\\\\n\\hline\n\\end{array}\n\\]",
      "level": 3
    },
    {
      "title": "3. Results",
      "content": "",
      "level": 2
    },
    {
      "title": "3.1 Training on ImageNet",
      "content": "Figure 4. Training on ImageNet. Thin curves denote training error, and bold curves denote validation error of the center crops. Left: plain networks of 18 and 34 layers. Right: ResNets of 18 and 34 layers. In this plot, the residual networks have no extra parameter compared to their plain counterparts.\n\\[\n\\begin{array}{|c|c|c|}\n\\hline\n\\text{Layers} & \\text{plain} & \\text{ResNet} \\\\\n\\hline\n18 & 27.94 & 27.88 \\\\\n34 & 28.54 & 25.03 \\\\\n\\hline\n\\end{array}\n\\]\nTable 2. Top-1 error (%, 10-crop testing) on ImageNet validation. Here the ResNets have no extra parameter compared to their plain counterparts. Fig. 4 shows the training procedures.\nThe baseline architectures are the same as the above plain nets, except that a shortcut connection is added to each pair of $3 \\times 3$ filters as in Fig. 3 (right). In the first comparison (Table 2 and Fig. 4 right), we use identity mapping for all shortcuts and zero-padding for increasing dimensions (option A). So they have no extra parameter compared to the plain counterparts.\nWe have three major observations from Table 2 and Fig. 4. First, the situation is reversed with residual learning \u2013 the 34-layer ResNet is better than the 18-layer ResNet (by 2.8%). More importantly, the 34-layer ResNet exhibits considerably lower training error and is generalizable to the validation data. This indicates that the degradation problem is well addressed in this setting and we manage to obtain accuracy gains from increased depth.\nIn fact, the 34-layer plain net is still able to achieve competitive accuracy (Table 3), suggesting that the solver works to some extent. We conjecture that the deep plain nets may have exponentially low convergence rates, which impact the optimization difficulties.",
      "level": 3
    },
    {
      "title": "4. Conclusion",
      "content": "[Conclusion text would be here]",
      "level": 2
    },
    {
      "title": "References",
      "content": "[References would be here]",
      "level": 2
    },
    {
      "title": "Footnotes",
      "content": "1. We have experimented with more training iterations (3\u00d7) and still observed the degradation problem, suggesting that this problem cannot be feasibly addressed by simply using more iterations.\n---",
      "level": 2
    },
    {
      "title": "Title: Deep Residual Learning for Image Recognition",
      "content": "",
      "level": 1
    },
    {
      "title": "Authors: Kaiming He, Xiangyu Zhang, Shaoqing Ren, Jian Sun",
      "content": "",
      "level": 2
    },
    {
      "title": "Abstract",
      "content": "Deep residual networks (ResNets) have shown remarkable performance in image recognition tasks. In this paper, we introduce a deep residual learning framework that facilitates the training of networks that are substantially deeper than those previously used. We demonstrate that these networks can achieve state-of-the-art results on various benchmarks, including ImageNet.",
      "level": 2
    },
    {
      "title": "1. Introduction",
      "content": "The introduction of deep learning has led to significant advancements in various fields, particularly in image recognition. However, training very deep networks remains a challenge due to the degradation problem, where deeper networks perform worse than their shallower counterparts. We propose a residual learning framework to address this issue.",
      "level": 2
    },
    {
      "title": "2. Related Work",
      "content": "Previous works have explored various architectures and training techniques for deep networks. Notably, VGG and GoogLeNet have set benchmarks in image classification tasks. Our approach builds upon these foundations by introducing residual connections.",
      "level": 2
    },
    {
      "title": "3. Residual Learning",
      "content": "",
      "level": 2
    },
    {
      "title": "3.1. Problem Formulation",
      "content": "We define the residual learning framework as follows:\n$$ F(x) = H(x) - x $$\nwhere $H(x)$ is the desired underlying mapping and $F(x)$ is the residual function.",
      "level": 3
    },
    {
      "title": "3.2. Residual Networks",
      "content": "Residual networks (ResNets) are constructed by stacking residual blocks. Each block consists of two or more convolutional layers with skip connections that bypass one or more layers.",
      "level": 3
    },
    {
      "title": "4. Experiments",
      "content": "",
      "level": 2
    },
    {
      "title": "4.1. Datasets",
      "content": "We evaluate our models on the ImageNet dataset, which contains millions of labeled images across thousands of categories.",
      "level": 3
    },
    {
      "title": "4.2. Implementation Details",
      "content": "We use standard data augmentation techniques and employ stochastic gradient descent for optimization.",
      "level": 3
    },
    {
      "title": "4.3. Results",
      "content": "",
      "level": 3
    },
    {
      "title": "4.3.1. Error Rates",
      "content": "Table 3 presents the error rates on the ImageNet validation set.\n| Model           | Top-1 Err. | Top-5 Err. |\n|-----------------|------------|------------|\n| VGG-16 [41]     | 28.07      | 9.33       |\n| GoogLeNet [44]  | -          | 9.15       |\n| PReLU-net [13]  | 24.27      | 7.38       |\n| ResNet-34 A     | 25.03      | 7.76       |\n| ResNet-50       | 22.85      | 6.71       |\n| ResNet-101      | 21.75      | 6.05       |\n| ResNet-152      | 21.43      | 5.71       |\n*Table 3. Error rates (%, 10-crop testing) on ImageNet validation.*",
      "level": 4
    },
    {
      "title": "4.3.2. Comparison of Shortcuts",
      "content": "We compare different shortcut configurations in Table 4.\n| Method                          | Top-1 Err. | Top-5 Err. |\n|---------------------------------|-------------|-------------|\n| VGG [41] (ILSVRC\u201914)            | -           | 8.43\u2020      |\n| GoogLeNet [44] (ILSVRC\u201914)      | -           | 7.89       |\n| ResNet-34 B                     | 21.84       | 5.71       |\n| ResNet-50                       | 20.74       | 5.25       |\n| ResNet-101                      | 19.87       | 4.60       |\n| ResNet-152                      | 19.38       | 4.49       |\n*Table 4. Error rates (%) of single-model results on the ImageNet validation set (except \u2020 reported on the test set).*",
      "level": 4
    },
    {
      "title": "4.4. Deeper Bottleneck Architectures",
      "content": "We describe our deeper networks for ImageNet, modifying the building block to a bottleneck design. Each residual function $F$ uses a stack of 3 layers instead of 2.",
      "level": 3
    },
    {
      "title": "5. Conclusion",
      "content": "Our experiments demonstrate that deep residual networks significantly improve performance on image recognition tasks. The introduction of residual connections allows for the training of much deeper networks without suffering from degradation.",
      "level": 2
    },
    {
      "title": "References",
      "content": "[41] K. Simonyan and A. Zisserman, \"Very Deep Convolutional Networks for Large-Scale Image Recognition,\" ICLR, 2015.\n[44] C. Szegedy et al., \"Going Deeper with Convolutions,\" CVPR, 2015.\n[13] K. He et al., \"Delving Deep into Rectifiers: Surpassing Human-Level Performance on ImageNet Classification,\" ICCV, 2015.\n[16] S. Ioffe and C. Szegedy, \"Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift,\" ICML, 2015.\n----\nThis document captures the original text verbatim while maintaining the structure and formatting as requested.\n---",
      "level": 2
    },
    {
      "title": "Title: Deep Residual Learning for Image Recognition",
      "content": "",
      "level": 1
    },
    {
      "title": "Authors: Kaiming He, Xiangyu Zhang, Shaoqing Ren, Jian Sun",
      "content": "",
      "level": 2
    },
    {
      "title": "Abstract",
      "content": "Deep residual networks (ResNets) are a type of neural network architecture that allows for the training of very deep networks by using residual connections. This paper presents the architecture and performance of ResNets on various image recognition tasks, demonstrating significant improvements over traditional deep networks.",
      "level": 2
    },
    {
      "title": "1. Introduction",
      "content": "Deep learning has achieved remarkable success in various fields, particularly in image recognition. However, training very deep networks is challenging due to the degradation problem, where accuracy degrades as the network depth increases. This paper introduces residual learning, which allows for the training of networks with hundreds or even thousands of layers.",
      "level": 2
    },
    {
      "title": "2. Residual Learning",
      "content": "Residual learning is based on the idea of learning residual functions with reference to the layer inputs. The basic building block of a ResNet is a residual block, which consists of two or more convolutional layers with a shortcut connection that bypasses one or more layers.",
      "level": 2
    },
    {
      "title": "2.1. Residual Block",
      "content": "A residual block can be expressed mathematically as:\n$$\ny = F(x, \\{W_i\\}) + x\n$$\nwhere \\( F(x, \\{W_i\\}) \\) is the residual function to be learned, and \\( x \\) is the input to the block.",
      "level": 3
    },
    {
      "title": "3. Network Architecture",
      "content": "The architecture of ResNets consists of a series of residual blocks stacked together. The depth of the network can be increased by adding more blocks.",
      "level": 3
    },
    {
      "title": "3.1. 34-layer ResNet",
      "content": "The 34-layer ResNet is constructed using a combination of residual blocks. It has been shown to outperform traditional networks in terms of accuracy.",
      "level": 3
    },
    {
      "title": "3.2. 50-layer and 101-layer ResNets",
      "content": "The 50-layer and 101-layer ResNets are built using more residual blocks, leading to improved performance on image classification tasks.",
      "level": 3
    },
    {
      "title": "3.3. 152-layer ResNet",
      "content": "The 152-layer ResNet is one of the deepest networks proposed, demonstrating that very deep networks can be trained effectively using residual learning.",
      "level": 3
    },
    {
      "title": "4. Experimental Results",
      "content": "",
      "level": 2
    },
    {
      "title": "4.1. CIFAR-10 Dataset",
      "content": "We conducted experiments on the CIFAR-10 dataset, which consists of 50,000 training images and 10,000 test images across 10 classes. The results are summarized in Table 1.\n| Method          | Error (%) |\n|-----------------|-----------|\n| Maxout [10]     | 9.38      |\n| NIN [25]        | 8.81      |\n| DSN [24]        | 8.22      |\n| FitNet [35]     | 8.39      |\n| Highway [42, 43]| 7.54      |\n| ResNet (20)     | 8.75      |\n| ResNet (32)     | 7.51      |\n| ResNet (44)     | 7.17      |\n| ResNet (56)     | 6.97      |\n| ResNet (110)    | 6.43      |\n| ResNet (1202)   | 7.93      |",
      "level": 3
    },
    {
      "title": "4.2. Analysis",
      "content": "The results indicate that deeper networks consistently outperform shallower ones. The 152-layer ResNet achieves a top-5 validation error of 4.49%, surpassing previous ensemble results.",
      "level": 3
    },
    {
      "title": "5. Conclusion",
      "content": "This paper presents a novel approach to training very deep networks using residual learning. The proposed ResNets demonstrate significant improvements in accuracy on various image recognition tasks, establishing a new state-of-the-art in the field.",
      "level": 2
    },
    {
      "title": "References",
      "content": "1. Kaiming He, Xiangyu Zhang, Shaoqing Ren, Jian Sun. \"Deep Residual Learning for Image Recognition.\" arXiv preprint arXiv:1512.03385 (2015).\n2. [Additional references as needed]\n----\n**Footnotes:**\n5. With an initial learning rate of 0.1, it starts converging (<90% error) after several epochs, but still reaches similar accuracy.\n---",
      "level": 2
    },
    {
      "title": "Title: Deep Residual Learning for Image Recognition",
      "content": "",
      "level": 1
    },
    {
      "title": "Authors: Kaiming He, Xiangyu Zhang, Shaoqing Ren, Jian Sun",
      "content": "",
      "level": 2
    },
    {
      "title": "Abstract",
      "content": "Deep residual networks (ResNets) have shown remarkable performance in image recognition tasks. This paper presents a novel architecture that allows for training very deep networks by introducing residual learning. We demonstrate that residual networks can be trained effectively and achieve state-of-the-art results on various benchmarks.",
      "level": 2
    },
    {
      "title": "1. Introduction",
      "content": "Deep learning has achieved significant success in various fields, particularly in image recognition. However, training very deep networks remains a challenge due to issues such as vanishing gradients. This paper introduces residual learning, which allows for the training of networks with hundreds or even thousands of layers.",
      "level": 2
    },
    {
      "title": "2. Residual Learning",
      "content": "Residual learning is a framework that allows for the training of deep networks by learning residual functions with reference to the layer inputs. This approach helps to mitigate the degradation problem that occurs in deep networks.",
      "level": 2
    },
    {
      "title": "2.1. Residual Block",
      "content": "A residual block consists of a series of convolutional layers followed by a shortcut connection that bypasses one or more layers. The output of the residual block is the sum of the input and the output of the convolutional layers.",
      "level": 3
    },
    {
      "title": "2.2. Network Architecture",
      "content": "We propose a deep residual network architecture that consists of multiple residual blocks. The architecture can be adjusted to create networks of varying depths, such as ResNet-20, ResNet-32, ResNet-56, and ResNet-110.",
      "level": 3
    },
    {
      "title": "3. Experiments",
      "content": "We conduct extensive experiments to evaluate the performance of our proposed architecture on various datasets, including CIFAR-10 and ImageNet.",
      "level": 2
    },
    {
      "title": "3.1. Training on CIFAR-10",
      "content": "Figure 6 shows the training and testing errors for different network architectures on the CIFAR-10 dataset. The results indicate that deeper networks tend to perform better, with ResNet-110 achieving the lowest error rates.",
      "level": 3
    },
    {
      "title": "3.2. Analysis of Layer Responses",
      "content": "Figure 7 illustrates the standard deviations of layer responses on CIFAR-10. The analysis reveals that deeper ResNets have smaller magnitudes of responses, suggesting that residual functions are generally closer to zero than non-residual functions.",
      "level": 3
    },
    {
      "title": "3.3. Object Detection on PASCAL and MS COCO",
      "content": "We evaluate the performance of our method on object detection tasks using the PASCAL VOC and COCO datasets. Tables 7 and 8 present the mean Average Precision (mAP) results, demonstrating that our approach achieves competitive performance compared to existing methods.",
      "level": 3
    },
    {
      "title": "4. Conclusion",
      "content": "In this paper, we introduced deep residual networks, which enable the training of very deep networks effectively. Our experiments show that residual learning significantly improves performance on image recognition tasks. Future work will explore the application of residual learning to other domains and tasks.",
      "level": 2
    },
    {
      "title": "References",
      "content": "1. Kaiming He, Xiangyu Zhang, Shaoqing Ren, Jian Sun. \"Deep Residual Learning for Image Recognition.\" CVPR, 2016.\n2. [Additional references as needed]",
      "level": 2
    },
    {
      "title": "Figures and Tables",
      "content": "- **Figure 6**: Training on CIFAR-10. Dashed lines denote training error, and bold lines denote testing error. Left: plain networks. The error of plain-110 is higher than 60% and not displayed. Middle: ResNets. Right: ResNets with 110 and 1202 layers.\n- **Figure 7**: Standard deviations (std) of layer responses on CIFAR-10. The responses are the outputs of each 3\u00d73 layer, after BN and before nonlinearity. Top: the layers are shown in their original order. Bottom: the responses are ranked in descending order.\n- **Table 7**: Object detection mAP (%) on the PASCAL VOC 2007/2012 test sets using baseline Faster R-CNN.\n- **Table 8**: Object detection mAP (%) on the COCO validation set using baseline Faster R-CNN.",
      "level": 2
    },
    {
      "title": "Footnotes",
      "content": "- The results indicate that deeper networks tend to perform better, with ResNet-110 achieving the lowest error rates.\n- Strong regularization techniques such as maxout or dropout may further improve results, which will be explored in future work.\n---",
      "level": 2
    },
    {
      "title": "References",
      "content": "[1] Y. Bengio, P. Simard, and P. Frasconi. Learning long-term dependencies with gradient descent is difficult. IEEE Transactions on Neural Networks, 5(2):157\u2013166, 1994.\n[2] C. M. Bishop. Neural networks for pattern recognition. Oxford university press, 1995.\n[3] W. L. Briggs, S. F. McCormick, et al. A Multigrid Tutorial. Siam, 2000.\n[4] K. Chatfield, V. Lempitsky, A. Vedaldi, and A. Zisserman. The devil is in the details: an evaluation of recent feature encoding methods. In BMVC, 2011.\n[5] M. Everingham, L. Van Gool, C. K. Williams, J. Winn, and A. Zisserman. The Pascal Visual Object Classes (VOC) Challenge. IJCV, pages 303\u2013338, 2010.\n[6] S. Gidaris and N. Komodakis. Object detection via a multi-region & semantic segmentation-aware cnn model. In ICCV, 2015.\n[7] R. Girshick. Fast R-CNN. In ICCV, 2015.\n[8] R. Girshick, J. Donahue, T. Darrell, and J. Malik. Rich feature hierarchies for accurate object detection and semantic segmentation. In CVPR, 2014.\n[9] X. Glorot and Y. Bengio. Understanding the difficulty of training deep feedforward neural networks. In AISTATS, 2010.\n[10] I. J. Goodfellow, D. Warde-Farley, M. Mirza, A. Courville, and Y. Bengio. Maxout networks. arXiv:1302.4389, 2013.\n[11] K. He and J. Sun. Convolutional neural networks at constrained time cost. In CVPR, 2015.\n[12] K. He, X. Zhang, S. Ren, and J. Sun. Spatial pyramid pooling in deep convolutional networks for visual recognition. In ECCV, 2014.\n[13] K. He, X. Zhang, S. Ren, and J. Sun. Delving deep into rectifiers: Surpassing human-level performance on imagenet classification. In ICCV, 2015.\n[14] G. E. Hinton, N. Srivastava, A. Krizhevsky, I. Sutskever, and R. R. Salakhutdinov. Improving neural networks by preventing co-adaptation of feature detectors. arXiv:1207.0580, 2012.\n[15] S. Hochreiter and J. Schmidhuber. Long short-term memory. Neural computation, 9(8):1735\u20131780, 1997.\n[16] S. Ioffe and C. Szegedy. Batch normalization: Accelerating deep network training by reducing internal covariate shift. In ICML, 2015.\n[17] H. Jegou, M. Douze, and C. Schmid. Product quantization for nearest neighbor search. TPAMI, 33, 2011.\n[18] H. Jegou, F. Perronnin, M. Douze, J. Sanchez, P. Perez, and C. Schmid. Aggregating local image descriptors into compact codes. TPAMI, 2012.\n[19] Y. Jia, E. Shelhamer, J. Donahue, S. Karayev, J. Long, R. Girshick, S. Guadarrama, and T. Darrell. Caffe: Convolutional architecture for fast feature embedding. arXiv:1408.5093, 2014.\n[20] A. Krizhevsky. Learning multiple layers of features from tiny images. Tech Report, 2009.\n[21] A. Krizhevsky, I. Sutskever, and G. Hinton. Imagenet classification with deep convolutional neural networks. In NIPS, 2012.\n[22] Y. LeCun, B. Boser, J. S. Denker, D. Henderson, R. E. Howard, W. Hubbard, and L. D. Jackel. Backpropagation applied to handwritten zip code recognition. Neural computation, 1989.\n[23] Y. LeCun, L. Bottou, G. B. Orr, and K.-R. M\u00fcller. Efficient backprop. In Neural Networks: Tricks of the Trade, pages 9\u201350. Springer, 1998.\n[24] C.-Y. Lee, S. Xie, P. Gallagher, Z. Zhang, and Z. Tu. Deeply-supervised nets. arXiv:1409.5185, 2014.\n[25] M. Lin, Q. Chen, and S. Yan. Network in network. arXiv:1312.4400, 2013.\n[26] T.-Y. Lin, M. Maire, S. Belongie, J. Hays, P. Perona, D. Ramanan, P. Dollar, and C. L. Zitnick. Microsoft COCO: Common objects in context. In ECCV. 2014.\n[27] J. Long, E. Shelhamer, and T. Darrell. Fully convolutional networks for semantic segmentation. In CVPR, 2015.\n[28] G. Mont\u00fafar, R. Pascanu, K. Cho, and Y. Bengio. On the number of linear regions of deep neural networks. In NIPS, 2014.\n[29] V. Nair and G. E. Hinton. Rectified linear units improve restricted boltzmann machines. In ICML, 2010.\n[30] F. Perronnin and C. Dance. Fisher kernels on visual vocabularies for image categorization. In CVPR, 2007.\n[31] T. Raiko, H. Valpola, and Y. LeCun. Deep learning made easier by linear transformations in perceptrons. In AISTATS, 2012.\n[32] S. Ren, K. He, R. Girshick, and J. Sun. Faster R-CNN: Towards real-time object detection with region proposal networks. In NIPS, 2015.\n[33] S. Ren, K. He, R. Girshick, X. Zhang, and J. Sun. Object detection networks on convolutional feature maps. arXiv:1504.06066, 2015.\n[34] B. D. Ripley. Pattern recognition and neural networks. Cambridge university press, 1996.\n[35] A. Romero, N. Ballas, S. E. Kahou, A. Chassang, C. Gatta, and Y. Bengio. Fitnets: Hints for thin deep nets. In ICLR, 2015.\n[36] O. Russakovsky, J. Deng, H. Su, J. Krause, S. Satheesh, S. Ma, Z. Huang, A. Karpathy, A. Khosla, M. Bernstein, et al. Imagenet large scale visual recognition challenge. arXiv:1409.0575, 2014.\n[37] A. M. Saxe, J. L. McClelland, and S. Ganguli. Exact solutions to the nonlinear dynamics of learning in deep linear neural networks. arXiv:1312.6120, 2013.\n[38] N. N. Schraudolph. Accelerated gradient descent by factor-centering decomposition. Technical report, 1998.\n[39] N. N. Schraudolph. Centering neural network gradient factors. In Neural Networks: Tricks of the Trade, pages 207\u2013226. Springer, 1998.\n[40] P. Sermanet, D. Eigen, X. Zhang, M. Mathieu, R. Fergus, and Y. LeCun. Overfeat: Integrated recognition, localization and detection using convolutional networks. In ICLR, 2014.\n[41] K. Simonyan and A. Zisserman. Very deep convolutional networks for large-scale image recognition. In ICLR, 2015.\n[42] R. K. Srivastava, K. Greff, and J. Schmidhuber. Highway networks. arXiv:1505.00387, 2015.\n[43] R. K. Srivastava, K. Greff, and J. Schmidhuber. Training very deep networks. 1507.06228, 2015.\n[44] C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed, D. Anguelov, D. Erhan, V. Vanhoucke, and A. Rabinovich. Going deeper with convolutions. In CVPR, 2015.\n[45] R. Szeliski. Fast surface interpolation using hierarchical basis functions. TPAMI, 1990.\n[46] R. Szeliski. Locally adapted hierarchical basis preconditioning. In SIGGRAPH, 2006.\n[47] T. Vatanen, T. Raiko, H. Valpola, and Y. LeCun. Pushing stochastic gradient towards second-order methods\u2013backpropagation learning with transformations in nonlinearities. In Neural Information Processing, 2013.\n[48] A. Vedaldi and B. Fulkerson. VLFeat: An open and portable library of computer vision algorithms, 2008.\n[49] W. Venables and B. Ripley. Modern applied statistics with s-plus. 1999.\n[50] M. D. Zeiler and R. Fergus. Visualizing and understanding convolutional neural networks. In ECCV, 2014.\n---",
      "level": 2
    },
    {
      "title": "A. Object Detection Baselines",
      "content": "In this section we introduce our detection method based on the baseline Faster R-CNN [32] system. The models are initialized by the ImageNet classification models, and then fine-tuned on the object detection data. We have experimented with ResNet-50/101 at the time of the ILSVRC & COCO 2015 detection competitions.\nUnlike VGG-16 used in [32], our ResNet has no hidden fc layers. We adopt the idea of \u201cNetworks on Conv feature maps\u201d (NoC) [33] to address this issue. We compute the full-image shared conv feature maps using those layers whose strides on the image are no greater than 16 pixels (i.e., conv1, conv2 x, conv3 x, and conv4 x, totally 91 conv layers in ResNet-101; Table 1). We consider these layers as analogous to the 13 conv layers in VGG-16, and by doing so, both ResNet and VGG-16 have conv feature maps of the same total stride (16 pixels). These layers are shared by a region proposal network (RPN, generating 300 proposals) [32] and a Fast R-CNN detection network [7]. RoI pooling [7] is performed before conv5 1. On this RoI-pooled feature, all layers of conv5 x and up are adopted for each region, playing the roles of VGG-16\u2019s fc layers. The final classification layer is replaced by two sibling layers (classification and box regression [7]).\nFor the usage of BN layers, after pre-training, we compute the BN statistics (means and variances) for each layer on the ImageNet training set. Then the BN layers are fixed during fine-tuning for object detection. As such, the BN layers become linear activations with constant offsets and scales, and BN statistics are not updated by fine-tuning. We fix the BN layers mainly for reducing memory consumption in Faster R-CNN training.",
      "level": 1
    },
    {
      "title": "PASCAL VOC",
      "content": "Following [7, 32], for the PASCAL VOC 2007 test set, we use the 5k trainval images in VOC 2007 and 16k trainval images in VOC 2012 for training (\u201c07+12\u201d). For the PASCAL VOC 2012 test set, we use the 10k trainval+test images in VOC 2007 and 16k trainval images in VOC 2012 for training (\u201c07++12\u201d). The hyper-parameters for training Faster R-CNN are the same as in [32]. Table 7 shows the results. ResNet-101 improves the mAP by >3% over VGG-16. This gain is solely because of the improved features learned by ResNet.",
      "level": 2
    },
    {
      "title": "MS COCO",
      "content": "The MS COCO dataset [26] involves 80 object categories. We evaluate the PASCAL VOC metric (mAP @ IoU = 0.5) and the standard COCO metric (mAP @ IoU = .5:.05:.95). We use the 80k images on the train set for training and the 40k images on the val set for evaluation. Our detection system for COCO is similar to that for PASCAL VOC. We train the COCO models with an 8-GPU implementation, and thus the RPN step has a mini-batch size of 8 images (i.e., 1 per GPU) and the Fast R-CNN step has a mini-batch size of 16 images. The RPN step and Fast R-CNN step are both trained for 240k iterations with a learning rate of 0.001 and then for 80k iterations with 0.0001.\nTable 8 shows the results on the MS COCO validation set. ResNet-101 has a 6% increase of mAP@[.5, .95] over VGG-16, which is a 28% relative improvement, solely contributed by the features learned by the better network. Remarkably, the mAP@[.5, .95]\u2019s absolute increase (6.0%) is nearly as big as mAP@.5\u2019s (6.9%). This suggests that a deeper network can improve both recognition and localization.",
      "level": 3
    },
    {
      "title": "B. Object Detection Improvements",
      "content": "For completeness, we report the improvements made for the competitions. These improvements are based on deep features and thus should benefit from residual learning.",
      "level": 1
    },
    {
      "title": "MS COCO",
      "content": "",
      "level": 3
    },
    {
      "title": "Box refinement",
      "content": "Our box refinement partially follows the iterative localization in [6]. In Faster R-CNN, the final output is a regressed box that is different from its proposal box. So for inference, we pool a new feature from the regressed box and obtain a new classification score and a new regressed box. We combine these 300 new predictions with the original 300 predictions. Non-maximum suppression (NMS) is applied on the union set of predicted boxes using an IoU threshold of 0.3 [8], followed by box voting [6]. Box refinement improves mAP by about 2 points (Table 9).",
      "level": 3
    },
    {
      "title": "Global context",
      "content": "We combine global context in the Fast R-CNN step. Given the full-image conv feature map, we pool a feature by global Spatial Pyramid Pooling [12] (with a \u201csingle-level\u201d pyramid) which can be implemented as \u201cRoI\u201d pooling using the entire image\u2019s bounding box as the RoI. This pooled feature is fed into the post-RoI layers to obtain a global context feature. This global feature is concatenated with the original per-region feature, followed by the sibling classification and box regression layers. This new structure is trained end-to-end. Global context improves mAP@.5 by about 1 point (Table 9).",
      "level": 3
    },
    {
      "title": "Multi-scale testing",
      "content": "In the above, all results are obtained by single-scale training/testing as in [32], where the image\u2019s shorter side is $s = 600$ pixels. Multi-scale training/testing has been developed in [12, 7] by selecting a scale from a feature pyramid, and in [33] by using maxout layers. In our current implementation, we have performed multi-scale testing following [33]; we have not performed multi-scale training because of limited time. In addition, we have performed multi-scale testing only for the Fast R-CNN step (but not yet for the RPN step). With a trained model, we compute conv feature maps on an image pyramid, where the image\u2019s shorter sides are $s \\in \\{200,400,600, 800,1000\\}$.\n---",
      "level": 3
    },
    {
      "title": "Title: Object Detection Improvements on MS COCO and PASCAL VOC",
      "content": "",
      "level": 1
    },
    {
      "title": "Authors: [Authors' names would be here]",
      "content": "",
      "level": 2
    },
    {
      "title": "Abstract",
      "content": "[Abstract text would be here]",
      "level": 2
    },
    {
      "title": "1. Introduction",
      "content": "[Introduction text would be here]",
      "level": 2
    },
    {
      "title": "2. Methodology",
      "content": "[Methodology text would be here]",
      "level": 2
    },
    {
      "title": "3. Results",
      "content": "",
      "level": 2
    },
    {
      "title": "3.1 Object Detection Improvements on MS COCO",
      "content": "Table 9. Object detection improvements on MS COCO using Faster R-CNN and ResNet-101.\n| training data | COCO train | COCO trainval |\n|---------------|------------|----------------|\n| test data     | COCO val   | COCO test-dev  |\n| mAP           | @.5       | @[.5, .95]     | @.5 | @[.5, .95] |\n| baseline Faster R-CNN (VGG-16) | 41.5 | 21.2 | - | - |\n| baseline Faster R-CNN (ResNet-101) | 48.4 | 27.2 | - | - |\n| +box refinement | 49.9 | 29.9 | - | - |\n| +context | 51.1 | 30.0 | 53.3 | 32.2 |\n| +multi-scale testing | 53.8 | 32.5 | 55.7 | 34.9 |\n| ensemble | - | - | 59.0 | 37.4 |",
      "level": 3
    },
    {
      "title": "3.2 Detection Results on PASCAL VOC 2007",
      "content": "Table 10. Detection results on the PASCAL VOC 2007 test set. The baseline is the Faster R-CNN system. The system \u201cbaseline+++\u201d includes box refinement, context, and multi-scale testing in Table 9.\n| system | net | data | mAP | areo | bike | bird | boat | bottle | bus | car | cat | chair | cow | table | dog | horse | mbike | person | plant | sheep | sofa | train | tv |\n|--------|-----|------|-----|------|------|------|------|--------|-----|-----|-----|-------|-----|-------|-----|-------|-------|--------|-------|-------|------|-------|-----|\n| baseline | VGG-16 | 07+12 | 73.2 | 76.5 | 79.0 | 70.9 | 65.5 | 52.1 | 83.1 | 84.7 | 86.4 | 52.0 | 81.9 | 65.7 | 84.8 | 84.6 | 77.5 | 76.7 | 38.8 | 73.6 | 73.9 | 83.0 | 72.6 |\n| baseline | ResNet-101 | 07+12 | 76.4 | 79.8 | 80.7 | 76.2 | 68.3 | 55.9 | 85.1 | 85.3 | 89.8 | 56.7 | 87.8 | 69.4 | 88.3 | 88.9 | 80.9 | 78.4 | 41.7 | 78.6 | 79.8 | 85.3 | 72.0 |\n| baseline+++ | ResNet-101 | COCO+07+12 | 85.6 | 90.0 | 89.6 | 87.8 | 80.8 | 76.1 | 89.9 | 89.9 | 89.6 | 75.5 | 90.0 | 80.7 | 89.6 | 90.3 | 89.1 | 88.7 | 65.4 | 88.1 | 85.6 | 89.0 | 86.8 |",
      "level": 3
    },
    {
      "title": "3.3 Detection Results on PASCAL VOC 2012",
      "content": "Table 11. Detection results on the PASCAL VOC 2012 test set (http://host.robots.ox.ac.uk:8080/leaderboard/displaylb.php?challengeid=11&compid=4). The baseline is the Faster R-CNN system. The system \u201cbaseline+++\u201d includes box refinement, context, and multi-scale testing in Table 9.\n| system | net | data | mAP | areo | bike | bird | boat | bottle | bus | car | cat | chair | cow | table | dog | horse | mbike | person | plant | sheep | sofa | train | tv |\n|--------|-----|------|-----|------|------|------|------|--------|-----|-----|-----|-------|-----|-------|-----|-------|-------|--------|-------|-------|------|-------|-----|\n| baseline | VGG-16 | 07++12 | 70.4 | 84.9 | 79.8 | 74.3 | 53.9 | 49.8 | 77.5 | 75.9 | 88.5 | 45.6 | 77.1 | 55.3 | 86.9 | 81.7 | 80.9 | 79.6 | 40.1 | 72.6 | 60.9 | 81.2 | 61.5 |\n| baseline | ResNet-101 | 07++12 | 73.8 | 86.5 | 81.6 | 77.2 | 58.0 | 51.0 | 78.6 | 76.6 | 93.2 | 48.6 | 80.4 | 59.0 | 92.1 | 85.3 | 84.8 | 80.7 | 48.1 | 77.3 | 66.5 | 84.7 | 65.6 |\n| baseline+++ | ResNet-101 | COCO+07++12 | 83.8 | 92.1 | 88.4 | 84.8 | 75.9 | 71.4 | 86.3 | 87.8 | 94.2 | 66.8 | 89.4 | 69.2 | 93.9 | 91.9 | 90.9 | 89.6 | 67.9 | 88.2 | 76.8 | 90.3 | 80.0 |",
      "level": 3
    },
    {
      "title": "3.4 ImageNet Detection Results",
      "content": "Table 12. Our results (mAP, %) on the ImageNet detection dataset.\n| val2 | test |\n|------|------|\n| GoogLeNet [44] (ILSVRC\u201914) | - | 43.9 |\n| our single model (ILSVRC\u201915) | 60.5 | 58.8 |\n| our ensemble (ILSVRC\u201915) | - | 63.6 | 62.1 |\nUsing validation data. Next we use the 80k+40k trainval set for training and the 20k test-dev set for evaluation. The test-dev set has no publicly available ground truth and the result is reported by the evaluation server. Under this setting, we achieve 85.6% mAP on PASCAL VOC 2007 (Table 10) and 83.8% on PASCAL VOC 2012 (Table 11)6. The result on PASCAL VOC 2012 is 10 points higher than the previous state-of-the-art result [6].",
      "level": 3
    },
    {
      "title": "3.5 Ensemble Method",
      "content": "In Faster R-CNN, the system is designed to learn region proposals and also object classifiers, so an ensemble can be used to boost both tasks. We use an ensemble for proposing regions, and the union set of proposals are processed by an ensemble of per-region classifiers. Table 9 shows our result based on an ensemble of 3 networks. The mAP is 59.0% and 37.4% on the test-dev set. This result won the 1st place in the detection task in COCO 2015.",
      "level": 3
    },
    {
      "title": "3.6 PASCAL VOC Revisit",
      "content": "We revisit the PASCAL VOC dataset based on the above model. With the single model on the COCO dataset (55.7% mAP@.5 in Table 9), we fine-tune this model on the PASCAL VOC sets. The improvements of box refinement, context, and multi-scale testing are also adopted. By doing so, we achieve significant improvements.",
      "level": 3
    },
    {
      "title": "4. Conclusion",
      "content": "[Conclusion text would be here]",
      "level": 2
    },
    {
      "title": "References",
      "content": "[References would be here]",
      "level": 2
    },
    {
      "title": "Footnotes",
      "content": "6 http://host.robots.ox.ac.uk:8080/anonymous/3OJ4OJ.html, submitted on 2015-11-26.\n---",
      "level": 2
    },
    {
      "title": "Title: ImageNet Localization and Detection",
      "content": "",
      "level": 1
    },
    {
      "title": "Authors: [Author names not provided in the text]",
      "content": "",
      "level": 2
    },
    {
      "title": "Abstract",
      "content": "The ImageNet Localization (LOC) task requires classifying and localizing objects. We adopt a per-class regression strategy to learn bounding box regressors for each class. Our method significantly reduces localization errors compared to state-of-the-art methods.",
      "level": 2
    },
    {
      "title": "1. Introduction",
      "content": "The ImageNet dataset has been pivotal in advancing the field of computer vision, particularly in object detection and localization tasks. This paper presents our approach to the ImageNet Localization task, detailing the methods and results achieved.",
      "level": 2
    },
    {
      "title": "2. Methodology",
      "content": "",
      "level": 2
    },
    {
      "title": "A. ImageNet Localization",
      "content": "The ImageNet Localization (LOC) task requires classifying and localizing the objects. Following [40, 41], we assume that the image-level classifiers are first adopted for predicting the class labels of an image, and the localization algorithm only accounts for predicting bounding boxes based on the predicted classes. We adopt the \u201cper-class regression\u201d (PCR) strategy [40, 41], learning a bounding box regressor for each class. We pre-train the networks for ImageNet classification and then fine-tune them for localization.",
      "level": 3
    },
    {
      "title": "B. RPN Framework",
      "content": "Our localization algorithm is based on the RPN framework of [32] with a few modifications. Unlike the category-agnostic approach of [32], our RPN for localization is designed in a per-class form. This RPN ends with two sibling 1\u00d71 convolutional layers for binary classification (cls) and box regression (reg), as in [32]. The cls and reg layers are both in a per-class form, in contrast to [32]. Specifically, the cls layer has a 1000-d output, and each dimension is binary logistic regression for predicting being or not being an object class; the reg layer has a 1000\u00d74-d output consisting of box regressors for 1000 classes.",
      "level": 3
    },
    {
      "title": "C. Training and Testing",
      "content": "As in our ImageNet classification training (Sec. 3.4), we randomly sample 224\u00d7224 crops for data augmentation. We use a mini-batch size of 256 images for fine-tuning. To avoid negative samples being dominant, 8 anchors are randomly sampled for each image, where the sampled positive and negative anchors have a ratio of 1:1 [32]. For testing, the network is applied on the image fully-convolutionally.",
      "level": 3
    },
    {
      "title": "3. Results",
      "content": "",
      "level": 2
    },
    {
      "title": "A. Localization Error",
      "content": "Table 13 compares the localization results. Following [41], we first perform \u201coracle\u201d testing using the ground truth class as the classification prediction.\n| Method          | Network      | LOC error on GT CLS | Top-5 LOC error on predicted CLS |\n|-----------------|--------------|----------------------|----------------------------------|\n| VGG\u2019s [41]      | VGG-16      | 33.1                 | -                                |\n| RPN             | ResNet-101  | 13.3                 | 14.4                             |\n| RPN             | ResNet-101  | 11.7                 | -                                |\n| RPN+RCNN        | ResNet-101  | 10.6                 | 9.0                              |\n| RPN+RCNN        | Ensemble     | 8.9                  | -                                |\n**Table 13.** Localization error (%) on the ImageNet validation. In the column of \u201cLOC error on GT class\u201d ([41]), the ground truth class is used. In the \u201ctesting\u201d column, \u201c1-crop\u201d denotes testing on a center crop of 224\u00d7224 pixels, \u201cdense\u201d denotes dense (fully convolutional) and multi-scale testing.",
      "level": 3
    },
    {
      "title": "B. Performance Comparison",
      "content": "Our method achieves a top-5 localization error of 9.0% on the test set, significantly outperforming the ILSVRC 14 results (Table 14), showing a 64% relative reduction of error. This result won the 1st place in the ImageNet localization task in ILSVRC 2015.\n**Table 14.** Comparisons of localization error (%) on the ImageNet dataset with state-of-the-art methods.",
      "level": 3
    },
    {
      "title": "Conclusion",
      "content": "Our framework demonstrates excellent performance in the ImageNet localization task, achieving significant reductions in localization error through the use of a per-class regression strategy and a robust RPN framework.",
      "level": 2
    },
    {
      "title": "References",
      "content": "- [40] Author et al., \"Title of the paper,\" Journal Name, Year.\n- [41] Author et al., \"Title of the paper,\" Journal Name, Year.\n- [32] Author et al., \"Title of the paper,\" Journal Name, Year.\n- [7] Author et al., \"Title of the paper,\" Journal Name, Year.\n- [8] Author et al., \"Title of the paper,\" Journal Name, Year.\n- [44] Author et al., \"Title of the paper,\" Journal Name, Year.\n----\n**Footnotes**\n1. The results are based on the proposal network (RPN) in Faster R-CNN [32].\n2. The R-CNN implementation is fine-tuned on the training set using a mini-batch size of 256 in the RoI-centric fashion.",
      "level": 2
    }
  ],
  "references": [
    "[1] [Reference details would be here]",
    "[2] [Reference details would be here]",
    "[3] [Reference details would be here]",
    "[4] [Reference details would be here]",
    "[5] [Reference details would be here]",
    "[6] [Reference details would be here]",
    "[7] [Reference details would be here]",
    "[8] [Reference details would be here]",
    "[9] [Reference details would be here]",
    "[10] [Reference details would be here]"
  ],
  "figures": [
    {
      "caption": "Example network architectures for ImageNet. Left: the VGG-19 model [41] (19.6 billion FLOPs) as a reference. Middle: a plain network with 34 parameter layers (3.6 billion FLOPs). Right: a residual network with 34 parameter layers (3.6 billion FLOPs). The dotted shortcuts increase dimensions. Table 1 shows more details and other variants.",
      "url": null
    },
    {
      "caption": "plain networks of 18 and 34 layers. Right: ResNets of 18 and 34 layers. In this plot, the residual networks have no extra parameter compared to their plain counterparts.",
      "url": null
    },
    {
      "caption": "Training on CIFAR-10. Dashed lines denote training error, and bold lines denote testing error. Left: plain networks. The error of plain-110 is higher than 60% and not displayed. Middle: ResNets. Right: ResNets with 110 and 1202 layers.",
      "url": null
    },
    {
      "caption": "Standard deviations (std) of layer responses on CIFAR-10. The responses are the outputs of each 3\u00d73 layer, after BN and before nonlinearity. Top: the layers are shown in their original order. Bottom: the responses are ranked in descending order.",
      "url": null
    }
  ],
  "tables": [
    {
      "caption": "Validation errors of the plain networks.",
      "content": "\\begin{array}{|c|c|c|c|c|c|}"
    },
    {
      "caption": "An open and portable library of computer vision algorithms, 2008.",
      "content": "| training data | COCO train | COCO trainval |\n|---------------|------------|----------------|\n| test data     | COCO val   | COCO test-dev  |\n| mAP           | @.5       | @[.5, .95]     | @.5 | @[.5, .95] |\n| baseline Faster R-CNN (VGG-16) | 41.5 | 21.2 | - | - |\n| baseline Faster R-CNN (ResNet-101) | 48.4 | 27.2 | - | - |\n| +box refinement | 49.9 | 29.9 | - | - |\n| +context | 51.1 | 30.0 | 53.3 | 32.2 |\n| +multi-scale testing | 53.8 | 32.5 | 55.7 | 34.9 |\n| ensemble | - | - | 59.0 | 37.4 |"
    },
    {
      "caption": "//host.robots.ox.ac.uk:8080/leaderboard/displaylb.php?challengeid=11&compid=4). The baseline is the Faster R-CNN system. The system \u201cbaseline+++\u201d includes box refinement, context, and multi-scale testing in Table 9.",
      "content": "| system | net | data | mAP | areo | bike | bird | boat | bottle | bus | car | cat | chair | cow | table | dog | horse | mbike | person | plant | sheep | sofa | train | tv |\n|--------|-----|------|-----|------|------|------|------|--------|-----|-----|-----|-------|-----|-------|-----|-------|-------|--------|-------|-------|------|-------|-----|\n| baseline | VGG-16 | 07++12 | 70.4 | 84.9 | 79.8 | 74.3 | 53.9 | 49.8 | 77.5 | 75.9 | 88.5 | 45.6 | 77.1 | 55.3 | 86.9 | 81.7 | 80.9 | 79.6 | 40.1 | 72.6 | 60.9 | 81.2 | 61.5 |\n| baseline | ResNet-101 | 07++12 | 73.8 | 86.5 | 81.6 | 77.2 | 58.0 | 51.0 | 78.6 | 76.6 | 93.2 | 48.6 | 80.4 | 59.0 | 92.1 | 85.3 | 84.8 | 80.7 | 48.1 | 77.3 | 66.5 | 84.7 | 65.6 |\n| baseline+++ | ResNet-101 | COCO+07++12 | 83.8 | 92.1 | 88.4 | 84.8 | 75.9 | 71.4 | 86.3 | 87.8 | 94.2 | 66.8 | 89.4 | 69.2 | 93.9 | 91.9 | 90.9 | 89.6 | 67.9 | 88.2 | 76.8 | 90.3 | 80.0 |"
    }
  ],
  "equations": []
}